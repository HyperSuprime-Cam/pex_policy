#include "boost/python.hpp"
#include "boost/python/const_aware.hpp"
#include "boost/python/to_python/copy_to_tuple.hpp"
#include "boost/python/from_python/container.hpp"
#include "boost/python/from_python/filesystem.hpp"
#include "boost/python/to_python/filesystem.hpp"
#include "indexing_suite/vector.hpp"
#include "lsst/bputils/exceptions.h"

#include "lsst/pex/policy.h"
#include "lsst/pex/policy/PolicyStreamDestination.h"
#include "lsst/pex/policy/PolicyStringDestination.h"
#include "lsst/pex/policy/paf/PAFWriter.h"

namespace bp = boost::python;

namespace lsst { namespace pex { namespace policy { %%scope(lsst::pex::policy)%%

namespace {

struct PyPolicy {

    static bp::str getTypeInfo(Policy const & self, std::string const & name) {
        return bp::str(self.getTypeInfo(name).name());
    }

    static bp::indexing::method_set_type const ptrVecMethods = 
        bp::indexing::all_methods
        & ~bp::indexing::method_sort 
        & ~bp::indexing::method_contains 
        & ~bp::indexing::method_count 
        & ~bp::indexing::method_has_key
        & ~bp::indexing::method_index
        ;

    static void declare() {
        bp::container_from_python_sequence< std::list<std::string> >();
        auto wrapper = bp::make_const_aware(
            %%auto_class<Policy>%%
        );
        {
            bp::scope inWrapper(wrapper.main_class());
            %%auto_enum(Policy::ValueType)%%
                  .export_values();
            bp::class_< Policy::BoolArray >("BoolArray")
                .def(bp::indexing::vector_suite< Policy::BoolArray >());
            bp::class_< Policy::IntArray >("IntArray")
                .def(bp::indexing::vector_suite< Policy::IntArray >());
            bp::class_< Policy::DoubleArray >("DoubleArray")
                .def(bp::indexing::vector_suite< Policy::DoubleArray >());
            bp::class_< Policy::StringArray >("StringArray")
                .def(bp::indexing::vector_suite< Policy::StringArray >());
            bp::class_< Policy::PolicyPtrArray >("PolicyPtrArray")
                .def(bp::indexing::vector_suite< Policy::PolicyPtrArray, ptrVecMethods >());
            bp::class_< Policy::ConstPolicyPtrArray >("ConstPolicyPtrArray")
                .def(bp::indexing::vector_suite< Policy::ConstPolicyPtrArray, ptrVecMethods >());
            bp::class_< Policy::FilePtrArray >("FilePtrArray")
                .def(bp::indexing::vector_suite< Policy::FilePtrArray, ptrVecMethods >());
        }
        wrapper.main_class()
            .%%auto_init%%
            .def(str(bp::self))
            ;
        wrapper
            .copy_method_to_proxy("__str__")
            .enable_shared_ptr()
            .%%auto_method(createPolicy, bp::return_value_policy< bp::manage_new_object >())%%
            .%%auto_method(createPolicyFromUrn, bp::return_value_policy< bp::manage_new_object >())%%
            .%%auto_method(createPolicyFile)%%
            .%%auto_method(getTypeByName)%%
            .%%auto_method(nameCount)%%
            .%%auto_method(names)%%
            .%%auto_method(paramNames)%%
            .%%auto_method(policyNames)%%
            .%%auto_method(fileNames)%%
            .%%auto_method(isDictionary)%%
            .%%auto_method(canValidate)%%
            .%%auto_method(getDictionary)%%
            .%%auto_method(setDictionary)%%
            .%%auto_method(validate)%%
            .%%auto_method(valueCount)%%
            .%%auto_method(isArray)%%
            .%%auto_method(exists)%%
            .%%auto_method(isBool)%%
            .%%auto_method(isInt)%%
            .%%auto_method(isDouble)%%
            .%%auto_method(isString)%%
            .%%auto_method(isPolicy)%%
            .%%auto_method(isFile)%%
            .def(
                "getTypeInfo", &getTypeInfo, bp::arg("name"),
                %%doc(Policy::getTypeInfo)%%
            )
            .def(
                "typeOf", &getTypeInfo, bp::arg("name"),
                %%doc(Policy::typeOf)%%
            )
            .%%auto_method(getValueType)%%
            .%%auto_method(getTypeName)%%
            .def( // these are manual because doxygen bug #648719 screws up the return type
                 "getPolicy",
                 (Policy::ConstPtr (Policy::*)(const std::string &) const)&Policy::getPolicy,
                 (bp::arg("name")),
                 %%doc(Policy::getPolicy[const])%%
             )
             .def(
                 "getPolicy",
                 (Policy::Ptr (Policy::*)(const std::string &))&Policy::getPolicy,
                 (bp::arg("name")),
                 %%doc(Policy::getPolicy[nonconst])%%
             )
            .%%auto_method(getFile)%%
            .%%auto_method(getBool)%%
            .%%auto_method(getInt)%%
            .%%auto_method(getDouble)%%
            .%%auto_method(getString)%%
            .%%auto_method(getPolicyArray)%%
            .%%auto_method(getConstPolicyArray)%%
            .%%auto_method(getFileArray)%%
            .%%auto_method(getBoolArray)%%
            .%%auto_method(getIntArray)%%
            .%%auto_method(getDoubleArray)%%
            .%%auto_method(getStringArray)%%
            .def( // more from the same doxygen bug
                 "set",
                 (void (Policy::*)(const std::string &, const Policy::Ptr &))&Policy::set,
                 (bp::arg("name"), bp::arg("value")),
                 %%doc(Policy::set[policy])%%
            )
            .%%auto_method(set)%%
            .def(
                 "add",
                 (void (Policy::*)(const std::string &, const Policy::Ptr &))&Policy::add,
                 (bp::arg("name"), bp::arg("value")),
                 %%doc(Policy::add[policy])%%
            )
            .%%auto_method(add)%%
            .%%auto_method(remove)%%
            .%%auto_method(loadPolicyFiles)%%
            .def(
                "mergeDefaults", &Policy::mergeDefaults,
                (bp::arg("defaultPol"), bp::arg("keepForValidation")=true, bp::arg("errs")=bp::object())
            )
            .%%auto_method(str)%%
            .%%auto_method(toString)%%
            .%%auto_method(asPropertySet)%%
            .def("_setBool", &Policy::setValue<bool>)
            .def("_addBool", &Policy::addValue<bool>)
            ;
    }

};

struct PyValidationError {

    static void declare() {
        auto wrapper = bputils::declareException<
            ValidationError,
            pex::exceptions::LogicErrorException
        >("ValidationError");
        %%in_class(ValidationError)%%
        {
            bp::scope inWrapper(wrapper);
            %%auto_enum(ValidationError::ErrorType)%%
                  .export_values();
        }
        wrapper
            // Because actual exception type is a proxy, there's some extra 
            // pure Python code to make this work as well (in __init__.py).
            .%%auto_init%%
            .%%auto_method(getParamCount)%%
            .%%auto_method(getParamNames, bp::return_value_policy<bp::copy_to_tuple>())%%
            .%%auto_method(getErrors)%%
            .%%auto_method(addError)%%
            .%%auto_method(describe)%%
            .setattr("EMPTY", ValidationError::EMPTY)
            ;
    }

};

struct PyDefinition {

    // Note: some template member functions are not wrapped, because they apparently weren't wrapped
    // in the SWIG interface either.
    // Also, some of the overloads of validate may be inherently ambiguous in Python.
    static void declare() {
        auto wrapper = bp::make_const_aware(
            %%auto_class<Definition>%%
        );
        wrapper.main_class()
            .%%auto_init%%
            ;
        wrapper
            .enable_shared_ptr()
            .%%auto_method(getName, bp::return_value_policy< bp::copy_const_reference >())%%
            .%%auto_method(getPrefix)%%
            .%%auto_method(setPrefix)%%
            .%%auto_method(isChildDefinition)%%
            .%%auto_method(setChildDefinition)%%
            .%%auto_method(isWildcard)%%
            .%%auto_method(setWildcard)%%
            .%%auto_method(setName)%%
            .%%auto_method(getData, bp::return_value_policy< bp::copy_const_reference >())%%
            .%%auto_method(setData)%%
            .%%auto_method(getType)%%
            .%%auto_method(getTypeName)%%
            .%%auto_method(getDefault)%%
            .%%auto_method(getDescription)%%
            .%%auto_method(getMaxOccurs)%%
            .%%auto_method(getMinOccurs)%%
            .%%auto_method(setDefaultIn[no_name,with_name])%%
            .%%auto_method(validate)%%
            .%%auto_method(validateRecurse)%%
            .%%auto_method(check)%%
            ;
    }

};

struct PyDictionary {

    static void declare() {
        auto wrapper = bp::make_const_aware(
            %%auto_class<Dictionary>%%
        );
        wrapper.main_class()
            .setattr("KW_DICT",        Dictionary::KW_DICT)
            .setattr("KW_DICT_FILE",   Dictionary::KW_DICT_FILE)
            .setattr("KW_TYPE",        Dictionary::KW_TYPE)
            .setattr("KW_DESCRIPTION", Dictionary::KW_DESCRIPTION)
            .setattr("KW_DEFAULT",     Dictionary::KW_DEFAULT)
            .setattr("KW_DEFINITIONS", Dictionary::KW_DEFINITIONS)
            .setattr("KW_CHILD_DEF",   Dictionary::KW_CHILD_DEF)
            .setattr("KW_ALLOWED",     Dictionary::KW_ALLOWED)
            .setattr("KW_MIN_OCCUR",   Dictionary::KW_MIN_OCCUR)
            .setattr("KW_MAX_OCCUR",   Dictionary::KW_MAX_OCCUR)
            .setattr("KW_MIN",         Dictionary::KW_MIN)
            .setattr("KW_MAX",         Dictionary::KW_MAX)
            .setattr("KW_VALUE",       Dictionary::KW_VALUE)
            .%%auto_init%%
            ;
        wrapper
            .enable_shared_ptr()
            .%%auto_method(getDefinitions)%%
            .%%auto_method(check)%%
            .%%auto_method(definedNames)%%
            .%%auto_method(getDef)%%
            .%%auto_method(makeDef, bp::return_value_policy< bp::manage_new_object >())%%
            .%%auto_method(hasSubDictionary)%%
            .%%auto_method(getSubDictionary)%%
            .%%auto_method(validate)%%
            .%%auto_method(loadPolicyFiles)%%
            .%%auto_method(getPrefix)%%
            .%%auto_method(setPrefix)%%
            ;
    }

};

struct PyPolicyWriter {

    static void declare() {
        auto wrapper = bp::make_const_aware(
            %%auto_class<PolicyWriter,noncopyable>%%
        );
        wrapper
            .enable_shared_ptr()
            .%%auto_method(write)%%
            .%%auto_method(writeBool)%%
            .%%auto_method(writeInt)%%
            .%%auto_method(writeDouble)%%
            .%%auto_method(writeString)%%
            .%%auto_method(writePolicy)%%
            .%%auto_method(writeFile)%%
            .%%auto_method(writeBools)%%
            .%%auto_method(writeInts)%%
            .%%auto_method(writeDoubles)%%
            .%%auto_method(writeStrings)%%
            .%%auto_method(writePolicies)%%
            .%%auto_method(writeFiles)%%
            .%%auto_method(close)%%
            .%%auto_method(toString)%%
            ;
    }

};

struct PyPolicySource {

    static void declare() {
        auto wrapper = bp::make_const_aware(
            %%auto_class<PolicySource,noncopyable>%%
        );
        wrapper
            .enable_shared_ptr()
            .%%auto_method(getFormatName, bp::return_value_policy< bp::copy_const_reference>())%%
            .%%auto_method(load)%%
            ;
    }
    
};

struct PyPolicyFile {

    static void declare() {
        auto wrapper = bp::make_const_aware(
            %%auto_class<PolicyFile>%%
        );
        wrapper.main_class()
            // manually wrap two constructors - the others are equivalent or unusable from Python
            // (because SupportedFormats and PolicyParserFactory are not wrapped) 
            .def(
                bp::init<std::string const &, boost::filesystem::path const &>(
                    (bp::arg("filepath"), bp::arg("reposDir")),
                    "Create a Policy file that points to a file with the given path\n"
                    "in a policy file repository.\n"
                )
            )
            .def(
                bp::init<std::string const &>(
                    bp::arg("filepath"),
                    "Create a Policy file that points to a file with the given path."
                )
            )
            ;
        wrapper
            .enable_shared_ptr()
            .%%auto_method(getPath)%%
            .%%auto_method(exists)%%
            .%%auto_method(getFormatName, bp::return_value_policy<bp::copy_const_reference>())%%
            .%%auto_method(load)%%
            ;
    }
    
};

struct PyDefaultPolicyFile {

    static void declare() {
        auto wrapper = bp::make_const_aware(
            %%auto_class<DefaultPolicyFile>%%
        );
        wrapper.main_class()
            .%%auto_init%%
            ;
        wrapper
            .enable_shared_ptr()
            .%%auto_method(getInstallPath)%%
            .%%auto_method(getRepositoryPath, bp::return_value_policy<bp::copy_const_reference>())%%
            .%%auto_method(installPathFor)%%
            .%%auto_method(load)%%
            ;
    }
    
};

struct PyUrnPolicyFile {

    static void declare() {
        auto wrapper = bp::make_const_aware(
            %%auto_class<UrnPolicyFile>%%
        );
        wrapper.main_class()
            .%%auto_init%%
            .setattr("URN_PREFIX", UrnPolicyFile::URN_PREFIX)
            .setattr("URN_PREFIX_ABBREV", UrnPolicyFile::URN_PREFIX_ABBREV)
            ;
        wrapper
            .enable_shared_ptr()
            .%%auto_method(productNameFromUrn)%%
            .%%auto_method(filePathFromUrn)%%
            .%%auto_method(reposFromUrn)%%
            .%%auto_method(looksLikeUrn)%%
            ;
    }
    
};

struct PyPolicyString {

    static void declare() {
        auto wrapper = bp::make_const_aware(
            %%auto_class<PolicyString>(bp::init<>("Create a null policy from an empty string."))%%
        );
        wrapper.main_class()
            // manually wrap one more constructor
            .def(
                bp::init<std::string const &>(
                    bp::arg("data"),
                    "Create a PolicyString that's wrapped around a given string."
                )
            )
            ;
        wrapper
            .enable_shared_ptr()
            .%%auto_method(getData, bp::return_value_policy<bp::copy_const_reference>())%%
            .%%auto_method(load)%%
            ;
    }
    
};

struct PyPolicyDestination {

    static void declare() {
        auto wrapper = bp::make_const_aware(
            %%auto_class<PolicyDestination,noncopyable>%%
        );
        wrapper.enable_shared_ptr();
    }

};

struct PyPolicyStreamDestination {

    static void declare() {
        auto wrapper = bp::make_const_aware(
            %%auto_class<PolicyStreamDestination>%%
        );
        // No constructors defined, because they take std::ostream and we can't make one from Python.
        wrapper.enable_shared_ptr();
    }

};

struct PyPolicyStringDestination {

    static void declare() {
        auto wrapper = bp::make_const_aware(
            %%auto_class<PolicyStringDestination>%%
        );
        wrapper.main_class()
            .%%auto_init%%
            ;
        wrapper
            .enable_shared_ptr()
            .%%auto_method(getData)%%
            ;
    }

};

} // anonymous

namespace paf { %%scope(lsst::pex::policy::paf)%%
namespace {

struct PyPAFWriter {

    static void declare() {
        auto wrapper = bp::make_const_aware(
            %%auto_class<PAFWriter,noncopyable>%%
        );
        wrapper.main_class()
            .%%auto_init[string]%%
            ;
        wrapper // all member functions are implementations of virtuals wrapped in PolicyWriter
            .enable_shared_ptr()
            ;
    }

};

} // anonymous
} // namespace paf

namespace {

void declarePolicy() {
    bp::filesystem_path_to_python();
    bp::filesystem_path_from_python_str();
    bputils::declareException<BadNameError,pex::exceptions::RuntimeErrorException>("BadNameError");
    bputils::declareException<DictionaryError,pex::exceptions::DomainErrorException>("DictionaryError");
    bputils::declareException<NameNotFound,pex::exceptions::NotFoundException>("NameNotFound");
    bputils::declareException<TypeError,pex::exceptions::DomainErrorException>("TypeError");
    bputils::declareException<ParserError,pex::exceptions::RuntimeErrorException>("ParserError");
    bputils::declareException<EOFError,ParserError>("EOFError");
    bputils::declareException<SyntaxError,ParserError>("SyntaxError");
    bputils::declareException<FormatSyntaxError,SyntaxError>("FormatSyntaxError");
    bputils::declareException<UnsupportedSyntax,SyntaxError>("UnsupportedSyntax");
    PyPolicy::declare();
    PyValidationError::declare();
    PyDefinition::declare();
    PyDictionary::declare();
    PyPolicyWriter::declare();
    PyPolicySource::declare();
    PyPolicyFile::declare();
    PyDefaultPolicyFile::declare();
    PyUrnPolicyFile::declare();
    PyPolicyString::declare();
    PyPolicyDestination::declare();
    PyPolicyStreamDestination::declare();
    PyPolicyStringDestination::declare();
    paf::PyPAFWriter::declare();
}

} // anonymous

}}} // namespace lsst::pex::policy

BOOST_PYTHON_MODULE(_policy) {
    bp::import("lsst.daf.base");
    lsst::pex::policy::declarePolicy();
}
